"""Generate a targeted manual cleanup plan from the zone audit report.

Inputs (local-only, gitignored):
- maintainers-local/reports/ZONE-AUDIT-REPORT.json (generated by audit_controls_zone_hygiene.py)

Outputs (local-only, gitignored):
- maintainers-local/reports/ZONE-CLEANUP-PLAN.md

This file is intended to be a living punch list for final semantic cleanup work.
"""

from __future__ import annotations

import json
import re
from pathlib import Path


REPO_ROOT = Path(__file__).resolve().parents[1]
REPORTS_ROOT = REPO_ROOT / "maintainers-local" / "reports"
AUDIT_JSON = REPORTS_ROOT / "ZONE-AUDIT-REPORT.json"
OUT_MD = REPORTS_ROOT / "ZONE-CLEANUP-PLAN.md"


def _classify_paren(label: str) -> str:
    """Roughly classify 'zone x (something)' drift strings."""
    s = label.lower()

    if any(k in s for k in ["dev", "developer", "test", "uat", "prod", "production", "sandbox", "critical"]):
        return "Environment-tier mapping (needs rewrite)"
    if any(k in s for k in ["approval", "cab", "legal", "committee", "no approval", "manager approval", "compliance"]):
        return "Approval/operating model (ok but should be rephrased)"
    if any(k in s for k in ["personal", "team", "enterprise"]):
        return "Near-canonical label (optional standardize)"
    if any(k in s for k in ["public", "general", "confidential", "restricted"]):
        return "Data classification mapping (needs rewrite)"
    return "Other (review)"


def main() -> int:
    REPORTS_ROOT.mkdir(parents=True, exist_ok=True)

    if not AUDIT_JSON.exists():
        raise FileNotFoundError(AUDIT_JSON)

    report = json.loads(AUDIT_JSON.read_text(encoding="utf-8"))
    files = report["files"]

    # Strict 3-zone model: any `Zone 4` / `Zone4` artifacts are legacy or tag collisions.
    legacy_zone4 = [f for f in files if int(f.get("zone4_mentions") or 0) > 0]
    ambiguous = [f for f in files if (f.get("ambiguous_zone_like_tokens") or {})]

    # Group mismatches by type.
    mismatch_groups: dict[str, list[tuple[str, str]]] = {}
    for f in files:
        for label in f.get("zone_paren_mismatches") or []:
            k = _classify_paren(label)
            mismatch_groups.setdefault(k, []).append((f["path"], label))

    # Zone mentions outside zone section — prioritize the worst.
    zone_leaks = [
        (f["path"], int(f.get("zone_mentions_outside_zone_section") or 0))
        for f in files
        if int(f.get("zone_mentions_outside_zone_section") or 0) > 0
    ]
    zone_leaks.sort(key=lambda x: (-x[1], x[0]))

    expected = [(f["path"], int(f.get("expected_colon_lines") or 0)) for f in files if int(f.get("expected_colon_lines") or 0)]

    md: list[str] = []
    md.append("# Zone Targeted Cleanup Plan\n")
    md.append("\n")
    md.append("This plan is generated by `scripts/generate_zone_cleanup_plan.py` and is meant to drive the *remaining* semantic cleanup work after safe automated fixes.\n")

    md.append("\n## What We Already Automated\n")
    md.append("- Removed legacy `Zone 4` table artifacts from earlier drafts (the governance model is strictly Zones 1-3).\n")
    md.append("- Normalized evidence heading: `### Compliance Evidence Checklist` → `### Verification Evidence`.\n")
    md.append("- Normalized `Expected:` formatting to `**EXPECTED:**` where detected.\n")

    md.append("\n## Source-of-Truth Zone Contract (from the Microsoft whitepaper)\n")
    md.append("- Zones are implemented practically via **Environment Groups** in PPAC and enforced via environment rules to prevent drift.\n")
    md.append("- `Zone 1` is **Personal Productivity** (often described as a Personal Developer Environment) with baseline controls and limited sharing.\n")
    md.append("- `Zone 2` is **Team Collaboration** with stricter enforcement and scoped access for shared/team agents.\n")
    md.append("- `Zone 3` is **Enterprise Managed** for high-risk / org-wide agents with the strongest controls, change control, and robust reporting.\n")
    md.append("- Only Zones 1-3 are governance zones. Any `Zone 4` / `Zone4` strings are legacy artifacts or example tag/value collisions and must be removed or renamed.\n")

    md.append("\n## Manual Cleanup Targets\n")

    md.append("\n### 1) Eliminate Non-canonical Zone-like Tokens (Not Governance Zones)\n")
    md.append("This repo uses a strict 3-zone governance model. Remove or rename any `Zone 4` / `Zone4` / `zone4_*` tokens, especially in examples, so customers do not interpret them as a fourth governance zone.\n")
    if legacy_zone4 or ambiguous:
        if legacy_zone4:
            md.append("\nLegacy `Zone 4` (spaced) tokens:\n")
            for f in legacy_zone4:
                md.append(f"- {f['path']} ({f['zone4_mentions']})\n")
        if ambiguous:
            md.append("\nAmbiguous tokens (`Zone4`, `zone4_*`) typically found in code/examples:\n")
            for f in ambiguous:
                details = f.get("ambiguous_zone_like_tokens") or {}
                detail_str = ", ".join(f"{k}={v}" for k, v in sorted(details.items()))
                md.append(f"- {f['path']}: {detail_str}\n")
    else:
        md.append("- None\n")

    md.append("\n### 2) Fix Zone Label Drift (Highest Priority Types First)\n")
    # Order matters.
    order = [
        "Environment-tier mapping (needs rewrite)",
        "Data classification mapping (needs rewrite)",
        "Approval/operating model (ok but should be rephrased)",
        "Near-canonical label (optional standardize)",
        "Other (review)",
    ]

    for k in order:
        items = mismatch_groups.get(k, [])
        md.append(f"\n#### {k}\n")
        if not items:
            md.append("- None\n")
            continue

        # Show up to 12 exemplars to keep the plan readable.
        for path, label in sorted(set(items))[:12]:
            md.append(f"- {path}: {label}\n")
        if len(set(items)) > 12:
            md.append(f"- ...and more (see {AUDIT_JSON.name})\n")

    md.append("\n### 3) Reduce Zone Mentions Outside `### Zone-Specific Configuration` (Targeted)\n")
    md.append("This is a semantic edit pass. Many mentions are valid (e.g., setup steps, routing), but **Governance Levels** sections should avoid duplicating zone requirements where possible.\n")
    md.append("\nWorst offenders (review first):\n")
    for path, count in zone_leaks[:12]:
        md.append(f"- {path} ({count})\n")

    if expected:
        md.append("\n### 4) Recheck Expected Formatting (Should Be Zero Now)\n")
        for path, count in expected:
            md.append(f"- {path} ({count})\n")

    OUT_MD.write_text("".join(md), encoding="utf-8", newline="\n")
    print(f"Wrote: {OUT_MD}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
